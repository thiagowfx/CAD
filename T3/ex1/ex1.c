#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* The number of elements of each vector. */
#define N ((int)1e7)

/* Maximum random number that can be generated (the minimum one is ZERO). */
#define MAX_RANDOM_NUMBER 10

/* Return a random integer in the [a,b) range. */
int get_random_int(int a, int b) {
	return a + (rand() % (b - a));
}

#ifdef DEBUG
#define DEBUGS(s, rank) printf("==> Rank #%d: s = %d\n", rank, s);
#else
#define DEBUGS(s, rank) ;
#endif

#ifdef DEBUG
#define DEBUGPP(start,end,vector,rank) do {\
	printf("Rank #%d\n", (rank));\
	for(int i = (start); i < (end); ++i) {\
		printf("%d ", vector[i]);\
	}\
	puts("");\
} while(0);
#else
#define DEBUGPP(start,end,vector,rank) ;
#endif

int main(int argc, char *argv[]) {
	MPI_Init(&argc, &argv);

	double starttime, endtime;
	starttime = MPI_Wtime();

	/* Rank of the current process. */
	int rank;

	/* Number of processes. */
	int p;

	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &p);

	/* Vectors generated by the master process. */
	int *v1 = NULL, *v2 = NULL;

	/* Vectors used to calculate the (partial) scalar product in each process. */
	int *w1 = NULL, *w2 = NULL;

	/* Used later on in the MPI_Scatterv function. */
	int *sendcounts = NULL, *displs = NULL;

	/* The scalar product. */
	int s = 0;

	/* Number of elements in each vector of each process (except the master). */
	const int n = N / p;

	/* Number of elements in each vector of the master process. */
	const int n0 = n + N % p;

	/* Allocate the initial vectors in the master process. */
	if (rank == 0) {
		v1 = (int*) malloc(N * sizeof(int));
		v2 = (int*) malloc(N * sizeof(int));

		srand(time(NULL));

		/* Populate both vectors with random numbers. */
		for(int i = 0; i < N; ++i) {
			v1[i] = get_random_int(0, MAX_RANDOM_NUMBER);
			v2[i] = get_random_int(0, MAX_RANDOM_NUMBER);
		}

		DEBUGPP(0, N, v1, rank)
		DEBUGPP(0, N, v2, rank)

		w1 = (int*) malloc(n0 * sizeof(int));
		w2 = (int*) malloc(n0 * sizeof(int));
	}
	else {
		w1 = (int*) malloc(n * sizeof(int));
		w2 = (int*) malloc(n * sizeof(int));
	}

	/* For MPI_Scatterv later on. */
	sendcounts = (int*) malloc(p * sizeof(int));
	displs = (int*) malloc(p * sizeof(int));

	/* Rationale: sendcounts[i] = n, except in the master process, where it is n0. */
	displs[0] = 0;
	sendcounts[0] = n0;
	for(int i = 1; i < p; ++i) {
		sendcounts[i] = n;

		/* Rationale: displs[i] is the latest displs position plus the
		 * size of the vector in the last position. */
		displs[i] = displs[i - 1] + sendcounts[i - 1];
	}

	MPI_Scatterv(v1, sendcounts, displs, MPI_INT, w1, sendcounts[rank], MPI_INT, 0, MPI_COMM_WORLD);
	MPI_Scatterv(v2, sendcounts, displs, MPI_INT, w2, sendcounts[rank], MPI_INT, 0, MPI_COMM_WORLD);

	DEBUGPP(0, sendcounts[rank], w1, rank)
	DEBUGPP(0, sendcounts[rank], w2, rank)

	/* Calculate the partial scalar product in each process. */
	for(int i = 0; i < (!rank ? n0 : n); ++i) {
		s += w1[i] * w2[i];
	}

	DEBUGS(s, rank)

	/* Reduce the parcial scalar products, obtaining the total one. */
	MPI_Allreduce(&s, &s, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
	endtime = MPI_Wtime();

	// just so we have a clean output
	MPI_Barrier(MPI_COMM_WORLD);
#ifdef DEBUG
	printf("Process #%d: the scalar product is %d\n", rank, s);
#else
	if (rank == 0) {
		printf("Process #%d: the scalar product is %d\n", rank, s);
	}
#endif

	MPI_Barrier(MPI_COMM_WORLD);
	/*if(rank == 0) {*/
		printf("Process #%d: total time: %lf seconds\n", rank, endtime - starttime);
	/*}*/

	/* De-allocate everything we used. */
	if(v1)
		free(v1);

	if(v2)
		free(v2);

	if(w1)
		free(w1);

	if(w2)
		free(w2);

	if(sendcounts)
		free(sendcounts);

	if(displs)
		free(displs);

	MPI_Finalize();

	return 0;
}
